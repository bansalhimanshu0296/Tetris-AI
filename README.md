# Tetris-AI #

This project was done as a part of CSCI-B-551 Elements of Artificial Intelligence Coursework under Prof. Dr. David Crandall.

## Command to run the program ##

python3 ./quintris.py [player(human/computer)] [mode(simple/animated)]

## Observation

The moves function which includes right, left, down, rotate and flip movements, and line clearing (score) function were  already given. 

## State space
All the configurations that we can obtain by adjusting random pieces on the board.

## Initial state
Empty tetris board.

## Goal state
The maximum scoring board.

## Successor state
The next board with the best block move.

## Utility/Evaluation function
(w1 * aggregate_height) + (w2 * bumpiness) + (w3 * number_of_holes) + (w4 * deepest_well) + (w5 * score).

## Approach and design decisions:

**Abstraction technique:** Genetic algorithm

We started by creating the following utility functions: 
1) Column height: Returns a list that includes the height value of each column. Using this function, we can calculate the aggregate height and maximum height. 
2) Bumpiness: Returns the sum of absolute height differences between the columns. 
3) Deepest well: Returns the maximum depth value
4) Number of holes: Returns the number of holes present in the board at that point of time.

We are implementing the genetic algorithm by assigning weights to these utility functions and also to the score function. We are calculating the heuristic value by multiplying the weights with their respective utility functions and returning the total heuristic value. We are now computing the best move by rotating the block piece and moving it to the left as much as we can. We then move the piece to the right by one column until we reach the quintris border and everytime we make this move, we calculate it is an optimal move. We then flip the piece and repeat the right movement process until the best move is found. 

We have generated a sample where we have generated random weights. We defined another function to compute the fitness of the sample. We have called the computer player class with the randomly generated weights and we have also generated a simple quintris object and called the start game function. Furthermore, we are adding the total score to the fitness of the sample taken. We have selected 10% of the population at random and then we are selecting two fittest candidates. We then do a crossover using both candidates with their respective weights. “ 'heightWeight': candidate1['fitness']* candidate1['heightWeight'] + candidate2['fitness']* candidate2['heightWeight'] “. 

We perform an offspring mutation where we are giving a small chance (5%) for the offspring to mutate. However, if the offspring does not mutate, it is adjusted by 0.2. We perform normalization on the weights of the sample. Once the number of offspring produced reaches a certain value of the original population size, some of the offspring are deleted and replaced forming the next generation of the population. 

For the main genetic function we have created a sample population and initialized the number of rounds. Next, we have appended the randomly generated candidates to the sample list. Then we computed the fitness of the sample. We have performed multiple iterations to select the best offspring. For this, we have called the pair_selection(), crossover() and offspring_mutation(). We then compute the fitness again and replace a portion of the total population with a new population. The weights with the greatest fit that are being generated by the genetic algorithm need to be replaced with the weights that we are passing initially in the quintris. 


## Challanges

Firstly, finding the right approach to this problem placed us in a very confusing state. Furthermore, even though we did figure out what algorithm we will be using, finding the right weight values for the algorithm was yet another challenge. We also had a tough time figuring out how to store the generated weights. Another challenge was that we were not able to implement the animated version for computer.

